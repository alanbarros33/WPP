import streamlit as st
import pandas as pd
import re
import plotly.express as px
from collections import Counter
from wordcloud import WordCloud
from datetime import datetime
import matplotlib.pyplot as plt
import io


# Configura√ß√£o do layout wide
st.set_page_config(layout="wide")

# Sidebar com logo e texto explicativo
with st.sidebar:
    st.image("logo.png", width=200)  # Atualizar com o caminho correto da logo
    st.markdown("""
    <div style="text-align: center;">
        <h2 style="color:#4B8BBE;">An√°lise de Conversas üìä</h2>
        <p>Esta aplica√ß√£o permite analisar conversas do WhatsApp para identificar sentimentos, 
        padr√µes de intera√ß√£o e t√≥picos mais discutidos.</p>
    </div>
    
    <hr style="border:1px solid #4B8BBE;">
    
    <h3 style="color:#4B8BBE;">Como Usar:</h3>
    <ol>
        <li><span style="color:#4CAF50;">üìÅ</span> <strong>Exporte</strong> o hist√≥rico de conversa do WhatsApp como um arquivo de texto (.txt).</li>
        <li><span style="color:#4CAF50;">‚¨ÜÔ∏è</span> <strong>Fa√ßa o upload</strong> do arquivo na aplica√ß√£o.</li>
        <li><span style="color:#4CAF50;">üîç</span> O sistema ir√° processar e exibir insights como a distribui√ß√£o de sentimentos, quem fala mais e outros padr√µes interessantes.</li>
    </ol>
    
    <hr style="border:1px solid #4B8BBE;">
    
    <div style="text-align: center;">
        <p style="font-size: 12px; color: gray;">¬© 2024 An√°lise de Conversas</p>
    </div>
    """, unsafe_allow_html=True)

# Dicion√°rio de palavras para categorizar sentimentos
word_sentiment = {
    "feliz": ["amor", "gostoso", "bom", "√≥timo", "perfeito", "‚ù§Ô∏è", "üíï", "üòÇ"],
    "raiva": ["droga", "raiva", "irritado", "mal", "merda", "üí©", "ü§¨"],
    "triste": ["triste", "desculpa", "saudade", "ü•∫"],
}

# Fun√ß√£o para categorizar mensagens
def categorize_message(message):
    for sentimento, palavras in word_sentiment.items():
        for palavra in palavras:
            if re.search(rf'\b{palavra}\b', message, re.IGNORECASE):
                return sentimento
    return "neutro"

# Fun√ß√£o para analisar o chat
def analyze_chat(file):
    lines = file.split("\n")
    data = {"Data": [], "Participante": [], "Mensagem": [], "Sentimento": []}
    
    for line in lines:
        if re.match(r'\[\d{2}/\d{2}/\d{4}, \d{2}:\d{2}:\d{2}\]', line):
            data_match = re.match(r'\[(.*?)\] (.*?): (.*)', line)
            if data_match:
                data["Data"].append(data_match.group(1))
                data["Participante"].append(data_match.group(2))
                mensagem = data_match.group(3)
                sentimento = categorize_message(mensagem)
                data["Mensagem"].append(mensagem)
                data["Sentimento"].append(sentimento)
    
    df = pd.DataFrame(data)
    df["Data"] = pd.to_datetime(df["Data"], format='%d/%m/%Y, %H:%M:%S')
    return df

# Fun√ß√£o para identificar quem inicia mais conversas
def quem_inicia_conversa(df):
    df_sorted = df.sort_values(by='Data')
    intervalos = df_sorted['Data'].diff().dt.total_seconds() > 600  # Intervalo de mais de 10 minutos
    iniciadores = df_sorted.loc[intervalos, 'Participante'].value_counts()
    return iniciadores.idxmax() if not iniciadores.empty else "N/A"

# Fun√ß√£o para identificar quem mais demora para responder
def quem_demora_para_responder(df):
    df_sorted = df.sort_values(by='Data')
    df_sorted['tempo_resposta'] = df_sorted['Data'].diff().dt.total_seconds()
    media_resposta = df_sorted.groupby('Participante')['tempo_resposta'].mean()
    return media_resposta.idxmax() if not media_resposta.empty else "N/A"

# Fun√ß√£o para identificar quem mais demonstra um determinado sentimento
def quem_demonstra_sentimento(df, sentimento):
    sent_counts = df[df['Sentimento'] == sentimento]['Participante'].value_counts()
    return sent_counts.idxmax() if not sent_counts.empty else "N/A"

# Fun√ß√£o para identificar picos de sentimentos
def identificar_picos_sentimentos(df):
    # Contagem de sentimentos por dia, excluindo 'neutro'
    sentiment_daily = df[df['Sentimento'] != 'neutro'].groupby([df['Data'].dt.date, 'Sentimento']).size().reset_index(name='Contagem')
    
    # Selecionar dias com pico para cada sentimento
    picos = {}
    for sentimento in ['feliz', 'raiva', 'triste']:
        sentimento_dia = sentiment_daily[sentiment_daily['Sentimento'] == sentimento].sort_values(by='Contagem', ascending=False).head(1)
        if not sentimento_dia.empty:
            picos[sentimento] = sentimento_dia.iloc[0]
    
    return picos


# Fun√ß√£o para gerar relat√≥rio em texto
def gerar_relatorio_txt(metrics_text, peaks_text):
    output = io.StringIO()

    output.write("Relat√≥rio de Conversas\n\n")
    output.write(f"Data da an√°lise: {pd.Timestamp.now().strftime('%d/%m/%Y %H:%M:%S')}\n\n")
    output.write("M√©tricas da Conversa:\n")
    output.write(metrics_text)
    output.write("\n\nPicos de Sentimentos:\n")
    output.write(peaks_text)
    output.write("\n\n")
    
    return output.getvalue()

# Fun√ß√µes de visualiza√ß√£o
def plot_sentiment_over_time(df):
    daily_sentiment = df.groupby([df['Data'].dt.date, "Sentimento"]).size().reset_index(name='Contagem')
    daily_total = daily_sentiment.groupby('Data')['Contagem'].sum().reset_index(name='Total')
    daily_sentiment = daily_sentiment.merge(daily_total, on='Data')
    daily_sentiment['Proporcao'] = daily_sentiment['Contagem'] / daily_sentiment['Total']
    
    fig = px.line(
        daily_sentiment, 
        x='Data', 
        y='Proporcao', 
        color='Sentimento',
        title="Evolu√ß√£o dos Sentimentos ao Longo do Tempo",
        labels={'Proporcao': 'Propor√ß√£o', 'Data': 'Data'},
        color_discrete_map={
            'feliz': 'blue', 
            'raiva': 'red', 
            'triste': 'purple', 
            'neutro': 'orange'
        }
    )
    fig.update_traces(mode='lines+markers', marker=dict(size=6))
    fig.update_layout(hovermode='x unified')
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("üìà **An√°lise**: Este gr√°fico mostra a varia√ß√£o de sentimentos ao longo do tempo. Cada cor representa um sentimento espec√≠fico.")

def plot_sentiment_distribution(df):
    """Gr√°fico de barras mostrando a propor√ß√£o de sentimentos"""
    sentiment_counts = df["Sentimento"].value_counts().reset_index()
    sentiment_counts.columns = ['Sentimento', 'Quantidade']
    
    fig = px.bar(
        sentiment_counts, 
        x='Sentimento', 
        y='Quantidade', 
        text='Quantidade',
        title="Distribui√ß√£o dos Sentimentos",
        labels={'Quantidade': 'Quantidade de Mensagens', 'Sentimento': 'Sentimento'},
        color='Sentimento',
        color_discrete_map={
            'feliz': 'blue', 
            'raiva': 'red', 
            'triste': 'purple', 
            'neutro': 'orange'
        }
    )
    fig.update_traces(texttemplate='%{text}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("üìä **An√°lise**: Este gr√°fico mostra a distribui√ß√£o dos diferentes sentimentos encontrados nas mensagens.")

def plot_participant_stats(df):
    """Gr√°fico de barras comparando a quantidade de mensagens por participante"""
    participant_counts = df["Participante"].value_counts().reset_index()
    participant_counts.columns = ['Participante', 'Quantidade']
    
    fig = px.bar(
        participant_counts, 
        x='Participante', 
        y='Quantidade', 
        text='Quantidade',
        title="Mensagens por Participante",
        labels={'Quantidade': 'Quantidade de Mensagens', 'Participante': 'Participante'},
        color='Participante',
        color_discrete_sequence=px.colors.qualitative.Pastel
    )
    fig.update_traces(texttemplate='%{text}', textposition='outside')
    fig.update_layout(uniformtext_minsize=8, uniformtext_mode='hide')
    st.plotly_chart(fig, use_container_width=True)
    st.markdown("üë• **An√°lise**: Este gr√°fico compara a quantidade de mensagens enviadas por cada participante, mostrando quem foi o mais ativo.")

def plot_wordcloud(df):
    """Nuvem de palavras das mensagens mais comuns"""
    all_text = ' '.join(df['Mensagem'])
    wordcloud = WordCloud(width=800, height=400, background_color='white').generate(all_text)
    
    plt.figure(figsize=(10, 5))
    plt.imshow(wordcloud, interpolation='bilinear')
    plt.axis("off")
    st.pyplot(plt)
    st.markdown("üåà **An√°lise**: Esta nuvem de palavras mostra as palavras mais frequentes nas mensagens, revelando os principais temas e emo√ß√µes.")

# Streamlit app
def main():
    st.markdown("""
    <div style="text-align: center;">
        <h1>Bem-vindo √† Ferramenta de An√°lise de Conversas do WhatsApp!</h1>
        <h2>Carregue seu arquivo de chat para come√ßar a explorar insights sobre suas conversas.</h2>
    </div>
    """, unsafe_allow_html=True)
    
    # Upload do arquivo
    uploaded_file = st.file_uploader("üìÇ Carregar arquivo de chat", type=["txt"])
    if uploaded_file is not None:
        file_content = uploaded_file.read().decode('utf-8')
        df = analyze_chat(file_content)

        # Filtros na parte superior
        col1, col2 = st.columns(2)
        with col1:
            participante_filter = st.selectbox("üë§ Selecionar Participante", options=["Todos"] + list(set(df["Participante"])))
        #with col2:
           #date_filter = st.date_input("Selecionar data", [])

        # Aplicar filtros
        if participante_filter != "Todos":
            df = df[df['Participante'] == participante_filter]
        #if date_filter:
            #df = df[df['Data'].dt.date == date_filter]

        # Gr√°ficos
        st.header("üìà An√°lises")
        
        col1, col2 = st.columns(2)
        
        with col1:
            plot_sentiment_over_time(df)
        with col2:
            plot_sentiment_distribution(df)

        st.header("üë• Estat√≠sticas dos Participantes")
        plot_participant_stats(df)

        st.header("üåü Nuvem de Palavras")
        plot_wordcloud(df)

        st.header("üîç M√©tricas e Picos de Sentimentos")

        # Texto din√¢mico de m√©tricas
        metrics_text = f"üîç **{quem_inicia_conversa(df)}** √© a pessoa que mais inicia conversas.\n"
        metrics_text += f"‚è≥ **{quem_demora_para_responder(df)}** √© a pessoa que mais demora para responder.\n"
        metrics_text += f"üòä **{quem_demonstra_sentimento(df, 'feliz')}** √© a pessoa que demonstra mais felicidade.\n"
        
        # Texto din√¢mico para picos de sentimentos
        peaks = identificar_picos_sentimentos(df)
        peaks_text = ""
        if 'feliz' in peaks:
            peaks_text += f"üéâ No dia **{peaks['feliz']['Data']}** houve um pico de felicidade.\n"
        if 'raiva' in peaks:
            peaks_text += f"üò† No dia **{peaks['raiva']['Data']}** houve um pico de raiva.\n"
        if 'triste' in peaks:
            peaks_text += f"üò¢ No dia **{peaks['triste']['Data']}** houve um pico de tristeza.\n"

        # Exibindo m√©tricas e picos juntos
        combined_text = metrics_text + "\n" + peaks_text
        st.text_area("üìÑ Resumo da An√°lise", combined_text, height=200)

        # Bot√£o de exporta√ß√£o
        col1, col2 = st.columns(2)
        #with col1:
            #if st.button("Exportar Relat√≥rio em PDF"):
                #pdf = generate_pdf_report(df)
                #buffer = io.BytesIO()
                #pdf.output(buffer, 'F')  # 'F' para salvar no buffer
                #buffer.seek(0)
                #st.download_button("Baixar Relat√≥rio PDF", data=buffer, file_name="relatorio_sentimentos.pdf", mime="application/pdf")
        with col2:
            if st.button("üìÑ Exportar Relat√≥rio em TXT"):
                report = gerar_relatorio_txt(metrics_text, peaks_text)
                st.download_button("‚¨áÔ∏è Baixar Relat√≥rio TXT", report, "relatorio.txt")

    else:
        st.markdown("""
        <div style="text-align: center; margin-top: 50px;">
            <p>‚òùÔ∏è Utilize o bot√£o acima para fazer o upload do seu hist√≥rico de conversas do WhatsApp.</p>
        </div>
        """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
